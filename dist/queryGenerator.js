// Generated by CoffeeScript 1.12.7
(function() {
  var QueryGenerator, _, util,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  util = require('util');

  
if (!String.prototype.endsWith) {
String.prototype.endsWith = function(searchString, position) {
var subjectString = this.toString();
if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
position = subjectString.length;
}
position -= searchString.length;
var lastIndex = subjectString.indexOf(searchString, position);
return lastIndex !== -1 && lastIndex === position;
};
}
;

  QueryGenerator = (function() {
    function QueryGenerator() {}

    QueryGenerator._operators = {
      notEqualOperator: {
        operator: '<>'
      },
      greaterOrEqualThanOperator: {
        operator: '>='
      },
      greaterThanOperator: {
        operator: '>'
      },
      lessOrEqualThanOperator: {
        operator: '<='
      },
      lessThanOperator: {
        operator: '<'
      },
      iNotLikeOperator: {
        operator: '!~~*'
      },
      iLikeOperator: {
        operator: '~~*'
      },
      equalOperator: {
        operator: '='
      }
    };

    QueryGenerator.toSql = function(args, config) {
      var columns, fromTable, joins, pageOptions, relations, sortOptions, useMainTablePagination, whereResult;
      args.options = args.options || {};
      whereResult = this._toWhere(args.where, config, args.options);
      relations = _.uniq(whereResult.relations.concat(args.relations || []));
      joins = this._toJoinSql(relations, config);
      columns = this._toColumnSql(relations, config, args.options);
      useMainTablePagination = config.useMainTablePagination || false;
      pageOptions = this._toOptions({
        limit: args.options.limit,
        offset: args.options.offset
      }, config);
      sortOptions = this._toOptions({
        sort: args.options.sort
      }, config);
      fromTable = useMainTablePagination ? "( SELECT " + config.table + ".* FROM " + (config.from || config.table) + " " + pageOptions + " ) AS " + config.table : config.from || config.table;
      return {
        sqlCount: "SELECT COUNT(DISTINCT " + config.table + ".\"id\") FROM " + (config.from || config.table) + " " + joins + " WHERE " + whereResult.where + ";",
        sqlSelectIds: "SELECT " + config.table + ".\"id\" FROM " + fromTable + " " + joins + " WHERE " + whereResult.where + " GROUP BY " + config.table + ".\"id\" " + sortOptions + " " + (!useMainTablePagination ? pageOptions : '') + ";",
        sqlSelect: "SELECT " + columns + " FROM " + fromTable + " " + joins + " WHERE " + whereResult.where + " " + sortOptions + " " + (!useMainTablePagination ? pageOptions : '') + ";",
        params: whereResult.params,
        relations: relations
      };
    };

    QueryGenerator._toOptions = function(options, config) {
      var direction, field, fieldConfig, limitValue, offsetValue, sort, sqlText;
      sqlText = '';
      if (options.sort) {
        sort = config.table + ".\"id\" ASC";
        direction = options.sort.indexOf('-') === 0 ? 'DESC' : 'ASC';
        field = options.sort.replace(/-|;/g, '');
        fieldConfig = this._getFieldConfigurationOrDefault(config, field);
        if (this._isSearchField(config, field)) {
          sort = fieldConfig.table + ".\"" + fieldConfig.column + "\" " + direction;
        }
        if (sort) {
          sqlText += "ORDER BY " + sort + " ";
        }
      }
      if (options.limit || options.offset) {
        offsetValue = parseInt(options.offset) || 0;
        limitValue = parseInt(options.limit) || 10;
        if (_.isNumber(offsetValue) && _.isNumber(limitValue)) {
          sqlText += "OFFSET " + offsetValue + " ";
          sqlText += "LIMIT " + limitValue;
        }
      }
      return sqlText = sqlText.trim();
    };

    QueryGenerator._toWhere = function(conditions, config, options) {
      var field, i, len, ref, result, tenantValue, tenantValues, value;
      if (_.isEmpty(conditions) && !(options != null ? options.tenant : void 0)) {
        return {
          where: '1=1',
          params: [],
          relations: []
        };
      }
      result = {
        where: [],
        params: [],
        relations: []
      };
      if (options != null ? options.tenant : void 0) {
        if (_.isArray(options.tenant.value)) {
          tenantValues = [];
          ref = options.tenant.value;
          for (i = 0, len = ref.length; i < len; i++) {
            tenantValue = ref[i];
            result.params.push(tenantValue);
            tenantValues.push("$" + result.params.length);
          }
          result.where.push("(" + config.table + ".\"" + options.tenant.column + "\" in (" + (tenantValues.join(', ')) + "))");
        } else {
          result.params.push(options.tenant.value);
          result.where.push("(" + config.table + ".\"" + options.tenant.column + "\" = $" + result.params.length + ")");
        }
      }
      for (field in conditions) {
        if (!hasProp.call(conditions, field)) continue;
        value = conditions[field];
        if (_.isArray(value)) {
          this._whereClauseAsArray(field, value, result, config);
        } else if (value === null || value === 'null' || value === '!null') {
          this._whereNullClause(field, value, result, config);
        } else {
          this._whereOperatorClause(field, value, result, config);
        }
      }
      result.where = "" + (result.where.join(' AND '));
      result.relations = _.uniq(result.relations);
      return result;
    };

    QueryGenerator._whereOperatorClause = function(field, value, result, configuration) {
      var columnName, comparedColumnName, comparedFieldConfig, fieldConfig, fieldOperator;
      fieldOperator = this._getWhereOperator(field);
      field = field.replace(fieldOperator.operator, '');
      fieldConfig = this._getFieldConfigurationOrDefault(configuration, field, result);
      columnName = fieldConfig.table + ".\"" + fieldConfig.column + "\"";
      if (this._isSearchField(configuration, value)) {
        comparedFieldConfig = this._getFieldConfigurationOrDefault(configuration, value, result);
        comparedColumnName = comparedFieldConfig.table + ".\"" + comparedFieldConfig.column + "\"";
        return result.where.push(columnName + " " + fieldOperator.operator + " " + comparedColumnName);
      } else {
        if (fieldConfig.format) {
          columnName = fieldConfig.format.replace('{{column}}', columnName);
        }
        result.params.push(fieldConfig.mapper(value));
        if (fieldConfig.orWhere && fieldConfig.orWhere.length) {
          return result.where.push("(" + columnName + " " + fieldOperator.operator + " $" + result.params.length + (this._addOrWhereClause(fieldConfig.orWhere, fieldOperator.operator, result.params.length)) + ")");
        }
        return result.where.push(columnName + " " + fieldOperator.operator + " $" + result.params.length);
      }
    };

    QueryGenerator._addOrWhereClause = function(orWhereArray, operator, paramIndex) {
      return orWhereArray.map(function(orWhere) {
        return " or " + orWhere.table + "." + orWhere.column + " " + operator + " $" + paramIndex;
      });
    };

    QueryGenerator._isSearchField = function(config, value) {
      if (config.search[value]) {
        return true;
      } else {
        return false;
      }
    };

    QueryGenerator._getWhereOperator = function(field) {
      var operatorHandler;
      operatorHandler = (function() {
        switch (false) {
          case !field.endsWith('<>'):
            return this._operators.notEqualOperator;
          case !field.endsWith('>='):
            return this._operators.greaterOrEqualThanOperator;
          case !field.endsWith('>'):
            return this._operators.greaterThanOperator;
          case !field.endsWith('<='):
            return this._operators.lessOrEqualThanOperator;
          case !field.endsWith('<'):
            return this._operators.lessThanOperator;
          case !field.endsWith('!~~*'):
            return this._operators.iNotLikeOperator;
          case !field.endsWith('~~*'):
            return this._operators.iLikeOperator;
          default:
            return this._operators.equalOperator;
        }
      }).call(this);
      return operatorHandler;
    };

    QueryGenerator._whereClauseAsArray = function(field, value, result, configuration) {
      var arrValue, arrValues, columnName, fieldConfig, fieldOperator, i, len, whereResult, withNull;
      arrValues = [];
      fieldOperator = this._getWhereOperator(field);
      field = field.replace(fieldOperator.operator, '');
      fieldConfig = this._getFieldConfigurationOrDefault(configuration, field, result);
      for (i = 0, len = value.length; i < len; i++) {
        arrValue = value[i];
        if (!(arrValue !== 'null' && arrValue !== null)) {
          continue;
        }
        result.params.push(fieldConfig.mapper(arrValue));
        arrValues.push("$" + result.params.length);
      }
      withNull = indexOf.call(value, 'null') >= 0 || indexOf.call(value, null) >= 0;
      whereResult = null;
      if (!fieldConfig.format) {
        whereResult = fieldConfig.table + ".\"" + fieldConfig.column + "\"";
      } else {
        if (fieldConfig.format) {
          columnName = fieldConfig.format.replace('{{column}}', fieldConfig.table + ".\"" + fieldConfig.column + "\"");
        }
        whereResult = "" + columnName;
      }
      if (fieldOperator.operator === this._operators.iLikeOperator.operator) {
        whereResult += " LIKE ANY(ARRAY[" + (arrValues.join(', ')) + "])";
      } else if (fieldOperator.operator === this._operators.iNotLikeOperator.operator) {
        whereResult += " NOT LIKE ANY(ARRAY[" + (arrValues.join(', ')) + "])";
      } else if (fieldOperator.operator === this._operators.notEqualOperator.operator) {
        whereResult += " NOT IN (" + (arrValues.join(', ')) + ")";
      } else {
        whereResult += " in (" + (arrValues.join(', ')) + ")";
      }
      if (withNull) {
        whereResult = "(" + whereResult + " OR " + fieldConfig.table + ".\"" + fieldConfig.column + "\" is null)";
      }
      return result.where.push(whereResult);
    };

    QueryGenerator._whereNullClause = function(field, value, result, configuration) {
      var fieldConfig;
      fieldConfig = this._getFieldConfigurationOrDefault(configuration, field, result);
      if (value === null || value === 'null') {
        result.where.push(fieldConfig.table + ".\"" + fieldConfig.column + "\" is null");
      }
      if (value === '!null') {
        return result.where.push(fieldConfig.table + ".\"" + fieldConfig.column + "\" is not null");
      }
    };

    QueryGenerator._getFieldConfigurationOrDefault = function(config, field, result) {
      var fieldConfiguration, mapper, searchConfig;
      fieldConfiguration = {
        table: config.table,
        column: field,
        mapper: function(value) {
          return value;
        }
      };
      searchConfig = config.search[field];
      if (searchConfig) {
        if (searchConfig.column) {
          fieldConfiguration.column = searchConfig.column;
        }
        if (searchConfig.format) {
          fieldConfiguration.format = searchConfig.format;
        }
        if (searchConfig.mapper) {
          mapper = config.mappers[searchConfig.mapper];
          if (mapper) {
            fieldConfiguration.mapper = mapper;
          } else {
            console.log("### WARNING: mapper " + searchConfig.mapper + " not found, it will be ignored.");
          }
        }
        if (searchConfig.relation && config.relations[searchConfig.relation]) {
          if (result) {
            result.relations.push(searchConfig.relation);
          }
          fieldConfiguration.table = config.relations[searchConfig.relation].table;
        }
        if (searchConfig.orWhere) {
          fieldConfiguration.orWhere = searchConfig.orWhere;
        }
      }
      return fieldConfiguration;
    };

    QueryGenerator._toColumnSql = function(relations, configuration, options) {
      var column, columnName, columns, i, len, ref;
      if (relations == null) {
        relations = [];
      }
      columns = [];
      ref = configuration.columns;
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        columnName = (column.table || configuration.table) + ".\"" + column.name + "\"";
        if (column.format) {
          columnName = column.format.replace('{{column}}', columnName);
        }
        if (options && options.columns && options.columns.length) {
          if (column.alias && options.columns.includes(column.alias.replace('this.', ''))) {
            columns.push(columnName + " \"" + column.alias + "\"");
          }
        } else {
          columns.push(columnName + " \"" + column.alias + "\"");
        }
      }
      this._getRelationRequiredChain(configuration, relations, function(relation) {
        var j, len1, ref1, results;
        ref1 = relation.columns;
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          column = ref1[j];
          columnName = (column.table || relation.table) + ".\"" + column.name + "\"";
          if (column.format) {
            columnName = column.format.replace('{{column}}', columnName);
          }
          if (options && options.columns && options.columns.length) {
            if (column.alias && options.columns.includes(column.alias.replace('this.', ''))) {
              results.push(columns.push(columnName + " \"" + column.alias + "\""));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(columns.push(columnName + " \"" + column.alias + "\""));
          }
        }
        return results;
      });
      return _.uniq(columns).join(', ');
    };

    QueryGenerator._toJoinSql = function(relations, configuration) {
      var joins;
      if (relations == null) {
        relations = [];
      }
      if (relations.length <= 0) {
        return '';
      }
      joins = [];
      this._getRelationRequiredChain(configuration, relations, function(relation) {
        return joins.push(relation.sql);
      });
      return _.uniq(joins).join(' ');
    };

    QueryGenerator._getRelationRequiredChain = function(configuration, relations, callback) {
      var i, len, relation, relationName, results;
      results = [];
      for (i = 0, len = relations.length; i < len; i++) {
        relationName = relations[i];
        relation = configuration.relations[relationName];
        if (relation) {
          if (relation.requires) {
            this._getRelationRequiredChain(configuration, relation.requires, callback);
          }
          results.push(callback(relation));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return QueryGenerator;

  })();

  module.exports = QueryGenerator;

}).call(this);
